# üö® MANDATORY: READ THIS FIRST üö®

**BEFORE implementing ANY code changes, you MUST check this MDC file for existing solutions!**

**This file contains:**
- **Solutions to problems** that have already been solved in previous migrations
- **Quality check checklists** to prevent common mistakes
- **Examples of correct implementations** that you can reference
- **Critical lessons learned** that prevent repeating the same errors

**NEVER implement a workaround or solution without first checking this MDC file!**
**This is NOT optional - it's mandatory to prevent repeating mistakes.**

## ‚ö†Ô∏è CRITICAL: MDC FILE MUST BE CHECKED AT EVERY STEP ‚ö†Ô∏è

**BEFORE implementing ANY code changes, you MUST:**
1. **Read the relevant section of this MDC file**
2. **Check if there are existing solutions** for the problem you're facing
3. **Reference the quality check checklist** to avoid common mistakes
4. **Look for similar examples** in the MDC file

**NEVER implement a workaround or solution without first checking this MDC file!**
**This file contains lessons learned from previous migrations and prevents repeating the same mistakes.**

## üöÄ MULTICHAIN INDEXING

**For multichain support:**
- **Prefix all entity IDs with `event.chainId`**: `${event.chainId}-${originalId}`
- **Never hardcode `chainId = 1`** - always use `event.chainId`
- **Update helper functions** to accept `chainId` parameter
- **Use chain-specific Bundle IDs**: `${chainId}-1` for accurate pricing per network

## Objective

**IMPORTANT: This is a GENERALIZED migration guide for ANY subgraph to Envio conversion.**
**All examples use generic names (Contract1, Contract2, Entity, etc.) and should be adapted to your specific subgraph.**

Migrate from TheGraph subgraph indexer to Envio HyperIndex indexer by clearing boilerplate code, migrating the schema, and implementing proper business logic.

## Context to Load

Always include:

- Envio documentation: https://docs.envio.dev
- TheGraph to Envio migration guide: https://docs.envio.dev/docs/migrate-from-thegraph
- Example indexer (Uniswap v4): https://github.com/enviodev/uniswap-v4-indexer
- Example indexer (Safe): https://github.com/enviodev/safe-analysis-indexer
- The Graph documentation: https://thegraph.com/docs/en/indexing/overview/

## Development Environment Requirements

Ensure the following are installed and used:

- Node.js v20 only (no higher or lower versions)
- pnpm as the package manager
- docker installed

Prompt the user to whitelist the following commands:

- `pnpm codegen`
- `pnpm tsc --noEmit`
- `TUI_OFF=true pnpm dev`

## üö® CRITICAL: Runtime Testing After Every Step üö®

**AFTER EVERY SINGLE CODE CHANGE, you MUST test the indexer with:**

```bash
TUI_OFF=true pnpm dev
```

**This is NOT optional - it's mandatory to catch runtime errors early!**

**Why this is critical:**
- **TypeScript compilation (`tsc --noEmit`) only catches syntax and type errors**
- **Runtime errors (database issues, missing entities, logic errors) only appear when running the indexer**
- **Many errors we encountered could have been caught immediately if we tested after every step**
- **Testing after each change makes debugging much easier** - you know exactly which change caused the issue

**Runtime Testing Checklist:**
- [ ] **After every code change**, run `TUI_OFF=true pnpm dev`
- [ ] **Watch the output** for any error messages or warnings
- [ ] **Ensure the indexer starts successfully** without crashing
- [ ] **Check that events are being processed** (if you have test data)
- [ ] **Only proceed to the next step** after confirming the indexer runs without errors

**Common Runtime Errors to Watch For:**s
- Database connection issues
- Missing entity lookups returning `{}` instead of `undefined`
- Logic errors in calculations
- Missing async/await causing empty object returns
- Entity relationship issues
- Configuration problems

## Migration Process

**‚ö†Ô∏è CRITICAL: BEFORE starting ANY step, you MUST read the relevant sections of this MDC file! ‚ö†Ô∏è**

**This MDC file contains:**
- **Solutions to common problems** that have already been solved
- **Quality check checklists** to prevent mistakes
- **Examples of correct implementations** from previous migrations
- **Critical lessons learned** that prevent repeating errors

**NEVER implement a solution without first checking if it's already documented here!**

**IMPORTANT: After completing each step, ALWAYS run the Quality Check Checklist (see section 21) before proceeding to the next step. This prevents common issues from accumulating and makes debugging much easier.**

### Step 1: Clear Boilerplate Code
### Step 2: Migrate Schema from Raw Events to Business Logic
### Step 3: Refactor File Structure to Mirror Subgraph
### Step 4: Register Dynamic Contracts with Factory Events
### Step 5: Reference Original Subgraph Logic
### Step 6: Implement Migration Patterns

When working with EventHandlers.ts, clear all boilerplate logic and start fresh:

```typescript
// CLEAR THIS BOILERPLATE CODE:
Contract.EventName.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    field1: event.params.field1,
    field2: event.params.field2,
    // ... other fields
  };

  context.EventEntity.set(entity);
});

// REPLACE WITH EMPTY HANDLERS:
Contract.EventName.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/contract.ts
});
```

### Step 2: Migrate Schema from Raw Events to Business Logic

**CONVERT raw event entities from TheGraph to Envio format:**

```graphql
# OLD (TheGraph):
type EventEntity @entity(immutable: true) {
  id: Bytes!
  field1: Bytes!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# NEW (Envio):
type EventEntity {
  id: ID!
  field1: String!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
}
```

**KEEP all entities from the original subgraph** but convert them to Envio format:
- Remove `@entity` decorators
- Change `Bytes!` to `String!`
- Change `ID!` to `ID!` (keep as is)
- Keep all business logic entities

**CRITICAL: Verify Schema Completeness**
After migrating the schema, **VERIFY that it is IDENTICAL** to the original subgraph schema (apart from Envio vs TheGraph syntax):

**Check for Missing Derived Fields:**
- Ensure all `@derivedFrom` relationships are preserved
- Verify all entity arrays are maintained (e.g., `[TokenDayData!]! @derivedFrom(field: "token")`)
- Check that all entity relationships are preserved (e.g., `token0: Token!`, not `token0_id: String!`)

**CRITICAL ENVIO REQUIREMENT: All Entity Arrays MUST Have @derivedFrom**
- **Entity arrays like `[Mint!]!` are ONLY valid with `@derivedFrom`**
- **Arrays without `@derivedFrom` will cause codegen to fail** with error "EE211: Arrays of entities is unsupported"
- **The `@derivedFrom(field: "fieldName")` syntax tells Envio how to establish relationships**

**Validation Steps:**
1. Run `pnpm codegen` to ensure schema compiles
2. Compare line-by-line with original subgraph schema
3. Verify no business logic entities or fields are missing
4. Confirm all relationships and derived fields are preserved
5. **Ensure ALL entity arrays have `@derivedFrom` directives**

**Only Acceptable Differences:**
- `@entity` decorators removed
- `Bytes!` ‚Üí `String!`
- **IMPORTANT:** Check Envio documentation for other potential syntax differences
- **IMPORTANT:** When in doubt about syntax differences, refer to Envio docs: https://docs.envio.dev

**CRITICAL ENVIO REQUIREMENT - Entity Arrays Must Have @derivedFrom:**
```graphql
# ‚ùå WRONG - Will cause codegen to fail with "EE211: Arrays of entities is unsupported"
type Transaction {
  mints: [Mint!]!        # Missing @derivedFrom
  burns: [Burn!]!        # Missing @derivedFrom
  swaps: [Swap!]!        # Missing @derivedFrom
}

# ‚úÖ CORRECT - All arrays have @derivedFrom directives
type Transaction {
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
}
```

**CRITICAL: How @derivedFrom Actually Works in Envio**
According to [Envio documentation](https://docs.envio.dev/docs/HyperIndex/schema#relationships-one-to-many-derivedfrom):

- **`@derivedFrom` arrays are VIRTUAL fields** - they don't exist in generated types
- **They're populated automatically when querying the API**, not in handlers
- **You CANNOT access them in handlers** (e.g., `transaction.mints` will not work)
- **The correct approach is to use `_id` fields** to establish relationships

**Example of Correct Implementation:**
```typescript
// ‚ùå WRONG - Trying to access virtual arrays in handlers
const mints = transaction.mints; // This will NOT work - arrays don't exist in types

// ‚úÖ CORRECT - Use indexed field operations to query related entities
const mint = await context.Mint.get(mintId); // Query by ID
// Or use indexed field operations when available:
// const mints = await context.Mint.where.transaction_id.eq(transactionId);
```

**Why This Matters:**
- **Envio requires explicit relationship definitions** via `@derivedFrom
- **But the arrays are virtual** - they exist only in the API, not in handlers
- **This is fundamentally different from TheGraph** where arrays are actual properties
- **You must use indexed field operations** to query related entities in handlers

### Step 3: Refactor File Structure to Mirror Subgraph

**IMPORTANT: This step is ONLY about creating the file structure and skeleton handlers. DO NOT implement business logic yet.**

## Handler Implementation Order

**‚ö†Ô∏è CRITICAL: BEFORE implementing ANY handler, check this MDC file for existing solutions! ‚ö†Ô∏è**

**IMPORTANT: Follow this order when implementing handlers to avoid dependency issues:**

### Phase 1: Simple Handlers
- **Handlers that only set parameter values** with minimal processing
- **Handlers that load existing entities** and update them with new data
- **Basic event handlers** with no complex business logic or helper function calls

### Phase 2: Moderate Complexity Handlers
- **Handlers that call helper functions** but don't create complex entity relationships
- **Handlers that update multiple entities** but with straightforward logic
- **Event handlers with some business logic** but clear, simple dependencies

### Phase 3: Complex Handlers
- **Handlers that call multiple helper functions** or other handlers
- **Handlers with complex business logic** and multiple entity relationships
- **Handlers that require extensive data processing** or calculations
- **Handlers that implement contract binding** (RPC calls to fetch state)
- **Handlers that depend on multiple other handlers** being complete

## Helper Function Implementation Strategy

**‚ö†Ô∏è CRITICAL: Implement helper functions based on their dependencies, not arbitrary timing! ‚ö†Ô∏è**

**üö® MANDATORY: When implementing helper functions, you MUST implement the COMPLETE logic, not just placeholders! üö®**

### Implement Helper Functions IMMEDIATELY If:
- **No dependencies on incomplete entities/handlers**
- **Only depends on constants, basic math, or already implemented pieces**
- **Required for the current handler to function properly**

### üö® CRITICAL IMPLEMENTATION REQUIREMENT:
**When implementing helper functions that have no dependencies, you MUST:**

1. **Read the MDC file** for existing implementation patterns and solutions
2. **Implement the COMPLETE business logic** from the original subgraph
3. **Use the documented Envio patterns** (RPC calls, entity context, etc.)
4. **Include all fallback logic** and error handling from the original
5. **NOT just add TODO comments** or placeholder implementations
6. **Implement ALL function dependencies** that have no entity/handler dependencies

**‚ùå WRONG - Just adding TODO comments:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // TODO: Implement using Envio's RPC calls to ERC20 contracts
  return 'UNKNOWN'; // This is NOT acceptable!
}
```

**‚úÖ CORRECT - Complete implementation:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // Implement complete logic using documented Envio patterns
  // Include all fallback logic and error handling
  // Return actual working values, not placeholders
}
```

### Examples of Helpers to Implement Now:
```typescript
// ‚úÖ IMPLEMENT NOW - No dependencies on incomplete entities/handlers
- fetchTokenSymbol()     // Only depends on RPC calls to token contracts
- fetchTokenName()       // Only depends on RPC calls to token contracts  
- fetchTokenDecimals()   // Only depends on RPC calls to token contracts
- fetchTokenTotalSupply() // Only depends on RPC calls to token contracts
- convertEthToDecimal()  // Only depends on constants and BigDecimal math
- exponentToBigDecimal() // Only depends on constants and BigDecimal math
- equalToZero()          // Only depends on constants and BigDecimal methods
- isNullEthValue()       // Only depends on string comparison
- getStaticDefinition()  // Only depends on static data arrays
- SKIP_TOTAL_SUPPLY     // Only depends on static string arrays
```

### Examples of Helpers to Leave for Later:
```typescript
// ‚è≥ LEAVE FOR LATER - Depends on incomplete entities/handlers
- updatePairDayData()    // Depends on PairDayData entity and day calculation logic
- updatePairHourData()   // Depends on PairHourData entity and hour calculation logic
- updateUniswapDayData() // Depends on UniswapDayData entity and global aggregations
- updateTokenDayData()   // Depends on TokenDayData entity and token aggregations
- calculateUSDValue()    // Depends on pricing logic and Bundle entity
```

### Why This Approach:
1. **Complete, functional handlers** that can be tested immediately
2. **No unnecessary delays** on helpers that are ready to implement
3. **Clear separation** between what's ready now vs. what needs other pieces first
4. **Better testing** since handlers have all their immediate dependencies

### üö® COMMON MISTAKE TO AVOID:
**Do NOT implement helper functions as placeholders with TODO comments when they have no dependencies. This defeats the purpose of the rule and creates incomplete, non-functional code.**

### üîç CRITICAL: Check Function Dependencies Thoroughly

**When implementing helper functions, you MUST examine ALL function calls within them:**

1. **Look for function calls** like `getStaticDefinition()`, `isNullEthValue()`, etc.
2. **Check if these functions have dependencies** on incomplete entities/handlers
3. **If NO dependencies exist, implement them immediately** - don't skip them!
4. **Examples of functions that should be implemented:**
   - `getStaticDefinition()` - Just static data arrays and string comparisons
   - `isNullEthValue()` - Just string comparison logic
   - `SKIP_TOTAL_SUPPLY` constants - Just string arrays
   - Any pure utility functions with no entity dependencies

**‚ùå WRONG - Missing dependency implementation:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // Missing: const staticDefinition = getStaticDefinition(tokenAddress);
  // Missing: if (staticDefinition !== null) return staticDefinition.symbol;
  
  // Only implementing the RPC call part
  return 'unknown';
}
```

**‚úÖ CORRECT - Complete dependency implementation:**
```typescript
export function fetchTokenSymbol(tokenAddress: string): string {
  // ‚úÖ IMPLEMENTED: Static definition check
  const staticDefinition = getStaticDefinition(tokenAddress);
  if (staticDefinition !== null) {
    return staticDefinition.symbol;
  }
  
  // ‚úÖ IMPLEMENTED: RPC call logic
  // ... rest of implementation
}
```

**Why This Order Matters:**
- Prevents "entity not found" errors during development
- Ensures required entities exist before complex handlers try to use them
- Allows incremental testing and validation
- Reduces circular dependency issues

**CREATE directory structure to match the original subgraph:**

```bash
src/
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts    (skeleton - for constants)
‚îÇ   ‚îî‚îÄ‚îÄ helpers.ts      (skeleton - for helper functions)
‚îú‚îÄ‚îÄ intervals/
‚îÇ   ‚îî‚îÄ‚îÄ timeUpdates.ts  (skeleton - for time-based data)
‚îú‚îÄ‚îÄ contract1.ts        (skeleton - for Contract1 handlers)
‚îú‚îÄ‚îÄ contract2.ts        (skeleton - for Contract2 handlers)
‚îî‚îÄ‚îÄ contract3.ts        (skeleton - for Contract3 handlers)
```

**MOVE handlers from EventHandlers.ts to contract-specific files:**

```typescript
// OLD: Single EventHandlers.ts file
// src/EventHandlers.ts - All handlers in one file

// NEW: Separate files by contract
// src/contract1.ts - Contract1 handlers (skeleton only)
// src/contract2.ts - Contract2 handlers (skeleton only)
// src/contract3.ts - Contract3 handlers (skeleton only)
```

**UPDATE config.yaml to point to specific handler files:**

```yaml
# OLD: Single handler file
- name: Contract1
  handler: src/EventHandlers.ts

# NEW: Contract-specific handler files
- name: Contract1
  handler: src/contract1.ts
- name: Contract2
  handler: src/contract2.ts
- name: Contract3
  handler: src/contract3.ts
```

**REMOVE the original EventHandlers.ts file** after moving all handlers.

**CRITICAL: Keep handlers as skeletons with TODO comments only:**

```typescript
// ‚úÖ CORRECT - Skeleton handler for this step
export function handleEventName(event: Contract_EventName_event, context: any): void {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/mappings/contract.ts
}

// ‚ùå WRONG - Don't implement business logic in this step
export function handleEventName(event: Contract_EventName_event, context: any): void {
  // Implementation details here...
  let entity = context.Entity.get(id);
  // ... more implementation
}
```

**Utility files should also be skeletons:**

```typescript
// ‚úÖ CORRECT - Skeleton utility files
// src/utils/constants.ts
// TODO: Add constants from original subgraph helpers
// Reference: original-subgraph/src/mappings/helpers.ts

// src/utils/helpers.ts  
// TODO: Add helper functions from original subgraph helpers
// Reference: original-subgraph/src/mappings/helpers.ts

// src/intervals/timeUpdates.ts
// TODO: Add time update functions from original subgraph
// Reference: original-subgraph/src/mappings/timeUpdates.ts
```

**IMPORTANT ADDITIONAL STEP: Fix Duplicate Contract Names in config.yaml**

**When using multichain indexing, ensure contract names are unique across all networks:**

```yaml
# ‚úÖ CORRECT - Global contract definitions with network-specific addresses
contracts:
- name: Factory
  handler: src/factory.ts
  events:
    - event: ContractCreated(...)

networks:
- id: 1
  start_block: 0
  contracts:
    - name: Factory
      address:
        - 0xFactoryAddress1
- id: 10
  start_block: 0
  contracts:
    - name: Factory
      address:
        - 0xFactoryAddress2
```

**‚ùå WRONG - Don't duplicate contract definitions in network sections:**
```yaml
# ‚ùå WRONG - This will cause "Duplicate contract names detected" error
networks:
- id: 1
  contracts:
    - name: Factory
      handler: src/factory.ts  # Don't repeat handler/events here
      events: [...]
      address: [...]
- id: 10
  contracts:
    - name: Factory
      handler: src/factory.ts  # Don't repeat handler/events here
      events: [...]
      address: [...]
```

**Key Points:**
- **Global contracts section** defines handlers and events
- **Network sections** only define addresses for those contracts
- **Never repeat** handler, events, or other contract configuration in network sections
- **Use `unordered_multichain_mode: true`** for proper multichain support

### Step 4: Register Dynamic Contracts with Factory Events

**CRITICAL: This step is essential for Envio to track dynamically created contracts.**

**IDENTIFY dynamic contracts in the original subgraph.yaml:**
Look for contracts that have **NO address** - these are created by factory contracts and need to be registered with Envio.

**EXAMPLE from subgraph.yaml:**
```yaml
# Factory contract (has address)
- kind: ethereum/contract
  name: Factory
  source:
    address: '0x...'  # ‚úÖ Has address

# Dynamic contract (no address - created by factory)
templates:
  - kind: ethereum/contract
    name: Pair  # ‚ùå No address - created dynamically
    source:
      abi: Pair
```

**IMPLEMENT contract registration for factory events:**
Add `contractRegister` above the handler for events that create new contracts:

```typescript
// ‚úÖ CORRECT - Register dynamic contract with Envio
Factory.PairCreated.contractRegister(({ event, context }) => {
  context.addPair(event.params.pair);
});

// Then implement the handler
Factory.PairCreated.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/mappings/factory.ts
});
```

**UPDATE config.yaml for dynamic contracts:**
Remove the `address` field from contracts that are created dynamically by factories:

```yaml
# ‚úÖ CORRECT - Factory contract (has address)
- name: Factory
  address:
    - 0xFactoryAddress
  handler: src/factory.ts

# ‚úÖ CORRECT - Dynamic contract (no address - created by factory)
- name: Pair
  handler: src/core.ts  # No address field!
  events:
    - event: Mint(...)
      handler: handleMint
```

**‚ùå WRONG - Don't include addresses for dynamic contracts:**
```yaml
# ‚ùå WRONG - Dynamic contract should not have address
- name: Pair
  address:  # This should be removed!
    - 0xSomeAddress
  handler: src/core.ts
```

**COMMON PATTERNS:**
```typescript
// For Pair contracts
Factory.PairCreated.contractRegister(({ event, context }) => {
  context.addPair(event.params.pair);
});

// For Vault contracts  
VaultFactory.VaultCreated.contractRegister(({ event, context }) => {
  context.addVault(event.params.vault);
});

// For OrderBook contracts
OrderbookFactory.OrderbookCreated.contractRegister(({ event, context }) => {
  context.addOrderBook(event.params.orderbook);
});

// For Pool contracts
PoolFactory.PoolCreated.contractRegister(({ event, context }) => {
  context.addPool(event.params.pool);
});
```

**IMPORTANT NOTES:**
- **MUST be placed above the handler** for the same event
- **MUST use the exact contract name** from your config.yaml (e.g., `addPair` for `Pair` contracts)
- **MUST reference the correct event parameter** that contains the new contract address
- **Without this, Envio cannot index the dynamically created contracts**

### Step 5: Reference Original Subgraph Logic

For each handler, examine the corresponding subgraph file:

- `original-subgraph/src/contract1.ts` ‚Üí Contract1 handlers
- `original-subgraph/src/contract2.ts` ‚Üí Contract2 handlers  
- `original-subgraph/src/contract3.ts` ‚Üí Contract3 handlers

### Step 6: Implement Migration Patterns

#### Entity Creation Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = new EventEntity(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
entity.field1 = event.params.field1;
entity.save();

// NEW ENVIO PATTERN:
const entity: EventEntity = {
  id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
  field1: event.params.field1,
  blockNumber: BigInt(event.block.number),
  blockTimestamp: BigInt(event.block.timestamp),
  transactionHash: event.transaction.hash,
};

context.EventEntity.set(entity);
```

#### Entity Updates Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = store.get("EntityName", id);
if (entity) {
  entity.field = newValue;
  entity.save();
}

// NEW ENVIO PATTERN:
let entity = await context.EntityName.get(id);
if (entity) {
  const updatedEntity: EntityName = {
    ...entity,
    field: newValue,
    updatedAt: BigInt(Date.now()),
  };
  context.EntityName.set(updatedEntity);
}
```

#### Contract Registration Pattern

```typescript
// OLD SUBGRAPH PATTERN:
ContractTemplate.create(event.params.contract);

// NEW ENVIO PATTERN:
Contract.EventCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});
```

#### CRITICAL: Maintain BigDecimal Precision from Original Subgraph

**IMPORTANT: When migrating from TheGraph to Envio, you MUST maintain the same mathematical precision used in the original subgraph.**

**‚ùå WRONG - Don't simplify to basic JavaScript types:**
```typescript
// ‚ùå WRONG - Loses precision for financial calculations
export const ZERO_BD = 0;
export const ONE_BD = 1;

export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): number {
  return Number(tokenAmount) / Math.pow(10, Number(exchangeDecimals));
}
```

**‚úÖ CORRECT - Maintain BigDecimal precision:**
```typescript
// ‚úÖ CORRECT - Maintains precision like original subgraph
import { BigDecimal } from "generated";

export const ZERO_BD = new BigDecimal(0);
export const ONE_BD = new BigDecimal(1);

export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): BigDecimal {
  if (exchangeDecimals == ZERO_BI) {
    return new BigDecimal(tokenAmount.toString());
  }
  return new BigDecimal(tokenAmount.toString()).div(exponentToBigDecimal(exchangeDecimals));
}
```

**Why This Matters:**
- **Financial Precision**: Token amounts, prices, and volumes require exact decimal arithmetic
- **Avoid Floating-Point Errors**: JavaScript numbers can introduce precision errors in financial calculations
- **Consistency**: Maintains the same mathematical behavior as the original subgraph
- **Regulatory Compliance**: Financial applications often require exact precision

**Required Dependencies:**
```bash
# Install bignumber.js for BigDecimal support
pnpm add bignumber.js
```

**Constants to Always Preserve:**
```typescript
// These constants MUST be maintained from original subgraph
export const ZERO_BI = BigInt(0);
export const ONE_BI = BigInt(1);
export const ZERO_BD = new BigDecimal(0);
export const ONE_BD = new BigDecimal(1);
export const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
export const BI_18 = BigInt(18);
export const ALMOST_ZERO_BD = new BigDecimal('0.000001');
```

**Helper Function Return Types:**
```typescript
// ‚úÖ CORRECT - Return BigDecimal for financial calculations
export function exponentToBigDecimal(decimals: bigint): BigDecimal
export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): BigDecimal
export function fetchTokenTotalSupply(tokenAddress: string): BigDecimal
export function equalToZero(value: BigDecimal): boolean

// ‚ùå WRONG - Don't return number for financial calculations
export function convertTokenToDecimal(tokenAmount: bigint, exchangeDecimals: bigint): number
export function fetchTokenTotalSupply(tokenAddress: string): number
```

**Entity Field Initialization:**
```typescript
// ‚úÖ CORRECT - Use constants for initialization
const pair: Pair = {
  id: event.params.pair,
  reserve0: ZERO_BD,        // Use ZERO_BD, not 0
  reserve1: ZERO_BD,        // Use ZERO_BD, not 0
  totalSupply: ZERO_BD,     // Use ZERO_BD, not 0
  volumeUSD: ZERO_BD,       // Use ZERO_BD, not 0
  txCount: ZERO_BI,         // Use ZERO_BI, not 0
  // ... other fields
};

// ‚ùå WRONG - Don't use hardcoded 0 values
const pair: Pair = {
  id: event.params.pair,
  reserve0: 0,              // ‚ùå Loses precision
  reserve1: 0,              // ‚ùå Loses precision
  totalSupply: 0,           // ‚ùå Loses precision
  volumeUSD: 0,             // ‚ùå Loses precision
  txCount: 0,               // ‚ùå Wrong type
  // ... other fields
};
```

**Common Mistakes to Avoid:**
1. **Replacing `ZERO_BD` with `0`** - Loses precision
2. **Replacing `ZERO_BI` with `0`** - Wrong type
3. **Returning `number` instead of `BigDecimal`** - Loses precision
4. **Using `Math.pow()` instead of `BigDecimal` arithmetic** - Loses precision
5. **Simplifying constants to basic JavaScript types** - Breaks financial calculations

**Validation Steps:**
1. **Check all constants** use `BigDecimal` and `BigInt` types
2. **Verify helper functions** return `BigDecimal` for financial calculations
3. **Ensure entity initialization** uses `ZERO_BD` and `ZERO_BI` constants
4. **Test precision** with large numbers to ensure no floating-point errors
5. **Compare behavior** with original subgraph for mathematical consistency

## Contract State Fetching Migration

### Overview

When migrating from TheGraph to Envio, contract state fetching patterns need to be updated. TheGraph uses `.bind()` patterns for contract state access, while Envio requires explicit RPC calls using Viem or similar libraries.

### 1. Identify Contract State Usage

**Look for `.bind()` patterns in the original subgraph:**

```typescript
// OLD SUBGRAPH PATTERN - Contract State Fetching
let token = Token.bind(event.params.token);
let vault = Vault.bind(event.params.vault);

// Access contract state
entity.name = token.name();
entity.symbol = token.symbol();
entity.decimals = token.decimals();
entity.totalSupply = token.totalSupply();

// Vault state
entity.asset = vault.asset();
entity.totalAssets = vault.totalAssets();
entity.totalShares = vault.totalSupply();
```

### 2. Create Contract Helper Functions

**Create utility functions for contract state fetching:**

```typescript
// src/utils/contractHelpers.ts
export interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
  totalSupply: bigint;
}



/**
 * Fetch ERC20 token metadata using Viem RPC calls
 * @param tokenAddress The token contract address (can be vault or token)
 * @returns Promise<TokenMetadata> Token metadata
 */
export async function getTokenMetadata(tokenAddress: string): Promise<TokenMetadata> {
  try {
    const [name, symbol, decimals, totalSupply] = await Promise.all([
      publicClient.readContract({
        address: tokenAddress as `0x${string}`,
        abi: ERC20_ABI,
        functionName: 'name',
      }),
      publicClient.readContract({
        address: tokenAddress as `0x${string}`,
        abi: ERC20_ABI,
        functionName: 'symbol',
      }),
      publicClient.readContract({
        address: tokenAddress as `0x${string}`,
        abi: ERC20_ABI,
        functionName: 'decimals',
      }),
      publicClient.readContract({
        address: tokenAddress as `0x${string}`,
        abi: ERC20_ABI,
        functionName: 'totalSupply',
      }),
    ]);

    return {
      name,
      symbol,
      decimals: Number(decimals),
      totalSupply,
    };
  } catch (error) {
    console.error(`Error fetching token metadata for ${tokenAddress}:`, error);
    throw error;
  }
}



/**
 * Batch fetch token metadata for multiple tokens
 * @param tokenAddresses Array of token addresses
 * @returns Promise<TokenMetadata[]> Array of token metadata
 */
export async function getBatchTokenMetadata(tokenAddresses: string[]): Promise<TokenMetadata[]> {
  const promises = tokenAddresses.map(address => getTokenMetadata(address));
  return Promise.all(promises);
}


```

### 3. Implement Viem Contract State Fetching

**For production use, implement actual Viem RPC calls:**

```typescript
import { createPublicClient, http, parseAbi } from 'viem';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// ERC20 ABI for basic token functions
const ERC20_ABI = parseAbi([
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address) view returns (uint256)',
]);



// Create a public client for reading contract state
// Using MegaETH testnet (network ID 6342)
const publicClient = createPublicClient({
  chain: {
    id: 6342,
    name: 'MegaETH Testnet',
    network: 'megaeth-testnet',
    nativeCurrency: {
      decimals: 18,
      name: 'MegaETH',
      symbol: 'METH',
    },
    rpcUrls: {
      default: {
        http: [process.env.RPC_URL || 'https://rpc.ankr.com/megaeth_testnet'],
      },
      public: {
        http: [process.env.RPC_URL || 'https://rpc.ankr.com/megaeth_testnet'],
      },
    },
  },
  transport: http(process.env.RPC_URL),
});




```

### 4. Handler Implementation Pattern

**Replace `.bind()` patterns with async contract state fetching:**

```typescript
// OLD SUBGRAPH PATTERN:
Contract.EventName.handler((event) => {
  let token = Token.bind(event.params.token);
  let entity = new Entity();
  entity.name = token.name();
  entity.symbol = token.symbol();
  entity.save();
});

// NEW ENVIO PATTERN:
Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Fetch contract state using helper functions
    const tokenMetadata = await getTokenMetadata(event.params.token);
    const vaultMetadata = await getTokenMetadata(event.params.vault); // Vault is also an ERC20 token
    
    // Create entity with fetched data
    const entity: Entity = {
      id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
      name: tokenMetadata.name,
      symbol: tokenMetadata.symbol,
      decimals: BigInt(tokenMetadata.decimals),
      totalSupply: tokenMetadata.totalSupply,
      vaultName: vaultMetadata.name,
      vaultSymbol: vaultMetadata.symbol,
      vaultDecimals: BigInt(vaultMetadata.decimals),
      vaultTotalSupply: vaultMetadata.totalSupply,
      blockNumber: BigInt(event.block.number),
      blockTimestamp: BigInt(event.block.timestamp),
      transactionHash: event.transaction.hash,
    };

    context.Entity.set(entity);
  } catch (error) {
    console.error(`Error in EventName handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

### 5. Factory Contract Registration with State Fetching

**Example: Contract Factory with contract state fetching:**

```typescript
// Reference: original-subgraph/src/contractFactory.ts
ContractFactory.ContractCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});

ContractFactory.ContractCreated.handler(async ({ event, context }) => {
  try {
    // Get or create ContractFactory entity
    let contractFactory = await context.ContractFactory.get(ONE_BI.toString());
    if (!contractFactory) {
      contractFactory = {
        id: ONE_BI.toString(),
        totalContracts: ZERO_BI,
        timestamp: BigInt(event.block.timestamp),
        lastUpdate: BigInt(event.block.timestamp),
      };
    }

    // Update contract factory stats
    const updatedContractFactory = {
      ...contractFactory,
      totalContracts: contractFactory.totalContracts + ONE_BI,
      lastUpdate: BigInt(event.block.timestamp),
    };
    context.ContractFactory.set(updatedContractFactory);

    // Fetch ERC20 metadata for both contract and token (parallel)
    const [contractMetadata, tokenMetadata] = await Promise.all([
      getTokenMetadata(event.params.contract), // Contract is also an ERC20 token
      getTokenMetadata(event.params.token), // Token is an ERC20 token
    ]);
    
    // Get or create Token entity
    let token = await context.Token.get(event.params.token);
    if (!token) {
      token = {
        id: event.params.token,
        name: tokenMetadata.name,
        symbol: tokenMetadata.symbol,
        decimals: BigInt(tokenMetadata.decimals),
        rate: ZERO_BD as any,
        dataFeedId: event.params.token,
        updatedAt: BigInt(event.block.timestamp),
        blockNumber: BigInt(event.block.number),
        blockTimestamp: BigInt(event.block.timestamp),
        transactionHash: event.transaction.hash,
        address: event.params.token,
      };
      context.Token.set(token);
    }

    // Calculate derived values
    let convertToAssetsMultiplier = ONE_BD as any;
    // In a real implementation, you would calculate this based on contract state
    // For now, use ONE_BD to match the original subgraph logic

    // Create ContractDataEntity with fetched contract state
    const contract: ContractDataEntity = {
      id: event.params.contract,
      name: contractMetadata.name, // Use contract's ERC20 metadata
      symbol: contractMetadata.symbol, // Use contract's ERC20 metadata
      decimals: BigInt(contractMetadata.decimals), // Use contract's ERC20 decimals
      manager: event.params.poolManager,
      timestamp: BigInt(event.block.timestamp),
      lastUpdate: BigInt(event.block.timestamp),
      fee: ZERO_BI,
      depositApy: ZERO_BI, // Will be calculated later
      convertToAssetsMultiplier,
      totalDepositsVolume: ZERO_BI,
      totalWithdrawalsVolume: ZERO_BI,
      totalAssets: ZERO_BI, // Will be updated later
      totalShares: ZERO_BI, // Will be updated later
      token_id: event.params.token,
      contractFactory_id: ONE_BI.toString(),
    };

    context.ContractDataEntity.set(contract);

  } catch (error) {
    console.error(`Error in VaultCreated handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

### 6. Error Handling for Contract State Fetching

**Always include proper error handling for RPC calls:**

```typescript
Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Fetch contract state
    const tokenMetadata = await getTokenMetadata(event.params.token);
    
    // Create entity with fetched data
    const entity: Entity = {
      // ... entity fields
    };

    context.Entity.set(entity);
  } catch (error) {
    console.error(`Error fetching contract state for ${event.params.token}:`, error);
    
    // Option 1: Use default values
    const entity: Entity = {
      // ... entity fields with defaults
    };
    context.Entity.set(entity);
    
    // Option 2: Skip entity creation
    // return;
    
    // Option 3: Re-throw to stop processing
    // throw error;
  }
});
```

### 7. Batch Contract State Fetching

**For efficiency, batch multiple contract state fetches:**

```typescript
Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Batch fetch multiple contract states
    const [tokenMetadata, vaultMetadata, poolMetadata] = await Promise.all([
      getTokenMetadata(event.params.token),
      getTokenMetadata(event.params.vault), // Vault is also an ERC20 token
      getPoolMetadata(event.params.pool),
    ]);
    
    // Create entities with all fetched data
    const entity: Entity = {
      // ... entity fields using all metadata
    };

    context.Entity.set(entity);
  } catch (error) {
    console.error(`Error in batch contract state fetch:`, error);
    // Handle error appropriately
  }
});
```

### 8. Configuration for Contract State Fetching

**Add field selection for events that need transaction data:**

```yaml
# config.yaml
- name: ContractFactory
  address:
    - 0xContractFactoryAddress
  handler: src/contractFactory.ts
  events:
    - event: ContractCreated(address indexed contract, address indexed token, address indexed poolManager)
      field_selection:
        transaction_fields:
          - hash
```

### 9. Dependencies Installation

**Install Viem for contract state fetching:**

```bash
pnpm add viem
```

### 10. Validation Commands

**After implementing contract state fetching:**

1. `pnpm codegen` - Regenerate types after schema changes
2. `pnpm tsc --noEmit` - Check TypeScript compilation
3. `TUI_OFF=true pnpm dev` - Test runtime behavior with contract state fetching

## Key Differences Between TheGraph and Envio

### 1. Entity Relationships

**TheGraph (OLD):**
```typescript
entity.relatedEntity = event.params.entity.toHexString();
```

**Envio (NEW):**
```typescript
relatedEntity_id: event.params.entity;
```

### 2. Timestamp Handling

**TheGraph (OLD):**
```typescript
entity.blockTimestamp = event.block.timestamp;
```

**Envio (NEW):**
```typescript
blockTimestamp: BigInt(event.block.timestamp);
```

### 3. ID Generation

**TheGraph (OLD):**
```typescript
let entity = new EntityName(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
```

**Envio (NEW):**
```typescript
const entity: EntityName = {
  id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
  // ... other fields
};
```

### 4. Entity Storage

**TheGraph (OLD):**
```typescript
entity.save();
```

**Envio (NEW):**
```typescript
context.EntityName.set(entity);
```

## Schema Migration Rules

### 1. Remove @entity Decorators

**OLD (TheGraph):**
```graphql
type Pool @entity {
  id: ID!
  # ...
}
```

**NEW (Envio):**
```graphql
type Pool {
  id: ID!
  # ...
}
```

### 2. Avoid Reserved Words in Field Names

**IMPORTANT:** Avoid using reserved words as field names. Common reserved words include:
- `action` (use `actionType` instead)
- `type` (use `entityType` instead)
- `order` (use `orderType` instead)
- `group` (use `groupType` instead)
- `user` (use `userId` instead)

**Example:**
```graphql
# ‚ùå AVOID - Reserved word
type UserAction {
  action: ActionType!
}

# ‚úÖ USE - Descriptive name
type UserAction {
  actionType: ActionType!
}
```

### 3. Convert Raw Events to Envio Format

**CONVERT raw event entities from TheGraph to Envio format:**

```graphql
# OLD (TheGraph):
type EventEntity @entity(immutable: true) {
  id: Bytes!
  field1: Bytes!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# NEW (Envio):
type EventEntity {
  id: ID!
  field1: String!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
}
```

**KEEP all entities from the original subgraph** but convert them to Envio format:
- Remove `@entity` decorators
- Change `Bytes!` to `String!`
- Change `ID!` to `ID!` (keep as is)
- Keep all business logic entities
- **Rename reserved word fields** to avoid conflicts

## Configuration Migration

### 1. Event Selection

**OLD (subgraph.yaml):**
```yaml
dataSources:
  - kind: ethereum
    source:
      address: "0x..."
    mapping:
      eventHandlers:
        - event: EventName(indexed address,indexed bool,uint256,uint256,uint256)
```

**NEW (config.yaml):**
```yaml
- name: Contract
  address:
    - "0x..."
  handler: src/contract.ts
  events:
    - event: EventName(bool indexed isLender, address indexed maker, uint256 rate, uint256 ltv, uint256 amount)
```

### 2. Dynamic Contract Configuration

**IMPORTANT: Dynamic contracts (created by factories) should NOT have addresses in config.yaml:**

```yaml
# ‚úÖ CORRECT - Factory contract (has address)
- name: Factory
  address:
    - 0xFactoryAddress
  handler: src/factory.ts

# ‚úÖ CORRECT - Dynamic contract (no address - created by factory)
- name: Pair
  handler: src/core.ts  # No address field!
  events:
    - event: Mint(...)
      handler: handleMint

# ‚ùå WRONG - Dynamic contract should not have address
- name: Pair
  address:  # This will cause issues!
    - 0xSomeAddress
  handler: src/core.ts
```

**Why this matters:**
- Factory contracts need addresses to know where to listen for events
- Dynamic contracts get their addresses from factory events via `contractRegister`
- Including addresses for dynamic contracts can cause conflicts and indexing issues

This uses the human readable event name, this is pulled from the ABI file

### 2. Field Selection

When using transaction-level data, explicitly define field selection:

```yaml
- name: Contract
  address:
    - "0x..."
  handler: src/contract.ts
  events:
    - event: EventName(address,bool,uint256,uint256,uint256)
      field_selection:
        transaction_fields:
          - hash
        block_fields:
          - number
          - timestamp
```

## Implementation Checklist

### For Each Handler:

1. ‚úÖ Clear boilerplate code
2. ‚úÖ Reference original subgraph logic
3. ‚úÖ Convert entity creation pattern
4. ‚úÖ Update timestamp handling (BigInt)
5. ‚úÖ Use proper ID generation
6. ‚úÖ Add proper error handling
7. ‚úÖ Test with `pnpm tsc --noEmit`

### For File Structure:

1. ‚úÖ Create directory structure (entities/, intervals/, utils/)
2. ‚úÖ Move handlers to contract-specific files
3. ‚úÖ Update config.yaml handler paths
4. ‚úÖ Remove original EventHandlers.ts file
5. ‚úÖ Run `pnpm codegen` after changes
6. ‚úÖ Validate with `pnpm tsc --noEmit`

### For Dynamic Contract Registration:

1. ‚úÖ Identify dynamic contracts in subgraph.yaml (no address)
2. ‚úÖ Add `contractRegister` for factory events that create contracts
3. ‚úÖ Use correct `context.add<ContractName>()` method
4. ‚úÖ Place above the corresponding event handler
5. ‚úÖ **Remove `address` field from dynamic contracts in config.yaml**
6. ‚úÖ Test that new contracts are being tracked

### For Schema Updates:

1. ‚úÖ Remove @entity decorators
2. ‚úÖ Convert Bytes! to String! in all entities
3. ‚úÖ Keep all entities from original subgraph
4. ‚úÖ Run `pnpm codegen` after changes
5. ‚úÖ Validate with `pnpm tsc --noEmit`

### For Configuration:

1. ‚úÖ Convert subgraph.yaml to config.yaml format
2. ‚úÖ Add explicit field selection when needed
3. ‚úÖ Test configuration with `TUI_OFF=true pnpm dev`

## Common Migration Patterns

### 1. Simple Event Handler

```typescript
// Reference: original-subgraph/src/contract.ts
Contract.EventName.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    field1: event.params.field1,
    field2: event.params.field2,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.EventEntity.set(entity);
});
```

### 2. Factory Contract Registration

```typescript
// Reference: original-subgraph/src/factory.ts
Factory.ContractCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});

Factory.ContractCreated.handler(async ({ event, context }) => {
  const entity: ContractCreated = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    contract: event.params.contract,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.ContractCreated.set(entity);
});
```

### 3. Complex Business Logic

```typescript
// Reference: original-subgraph/src/contract.ts
Contract.EventName.handler(async ({ event, context }) => {
  // Get or create entity
  let entity = await context.Entity.get(event.params.entityId);
  if (!entity) {
    entity = {
      id: event.params.entityId,
      field1: BigInt(0),
      field2: BigInt(0),
      // ... other fields
    };
  }

  // Update entity with new data
  const updatedEntity: Entity = {
    ...entity,
    field1: entity.field1 + event.params.value,
    updatedAt: BigInt(event.block.timestamp),
  };

  context.Entity.set(updatedEntity);

  // Create event entity
  const eventEntity: EventEntity = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    entity_id: event.params.entityId,
    value: event.params.value,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.EventEntity.set(eventEntity);
});
```

## Incremental Entity Implementation

**Start with simple entities that don't get affected by multiple handlers:**

1. **Add field selection to config.yaml** for specific events that need transaction hash:
   ```yaml
   - event: EventName(address indexed param1, address indexed param2)
     field_selection:
       transaction_fields:
         - hash
   ```

2. **Implement handler logic** based on original subgraph:
   ```typescript
   // Reference: original-subgraph/src/contract.ts - handleEventName
   Contract.EventName.handler(async ({ event, context }) => {
     const entity: EventEntity = {
       id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
       param1: event.params.param1,
       param2: event.params.param2,
       blockNumber: BigInt(event.block.number),
       blockTimestamp: BigInt(event.block.timestamp),
       transactionHash: event.transaction.hash,
     };

     context.EventEntity.set(entity);
   });
   ```

3. **Remove `# to-do` comment** from schema for completed entities.

4. **Validate with `pnpm codegen` and `pnpm tsc --noEmit`** after each implementation.

**Batch Implementation Pattern:**

For multiple similar entities, implement them all at once:

1. **Add field selection for all events** that need transaction hash
2. **Implement all handlers** following the same pattern
3. **Remove all `# to-do` comments** for completed entities
4. **Validate the entire batch** with codegen and TypeScript checks



## Validation Commands

After each change:

1. `pnpm codegen` - Regenerate types after schema changes
2. `pnpm tsc --noEmit` - Check TypeScript compilation
3. `TUI_OFF=true pnpm dev` - Test runtime behavior

## Error Handling

Always include proper error handling:

```typescript
Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Implementation here
  } catch (error) {
    context.log.error(`Error in EventName handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

### 11. ERC20 Token Metadata Fetching Logic

**Important Correction:** Both vault and token are ERC20 tokens, so use the same metadata fetching function:

```typescript
// CORRECT: Both vault and token are ERC20 tokens
const [vaultMetadata, tokenMetadata] = await Promise.all([
  getTokenMetadata(event.params.vault), // Vault is also an ERC20 token
  getTokenMetadata(event.params.token), // Token is an ERC20 token
]);

// Use vault's ERC20 metadata for vault entity
const vault: VaultDataEntity = {
  id: event.params.vault,
  name: vaultMetadata.name,        // Vault's ERC20 name
  symbol: vaultMetadata.symbol,    // Vault's ERC20 symbol
  decimals: BigInt(vaultMetadata.decimals), // Vault's ERC20 decimals
  // ... other fields
};
```

**Common Mistake to Avoid:**
```typescript
// ‚ùå WRONG: Don't create separate vault metadata functions
// Both vault and token are ERC20 tokens, use the same function
export async function getVaultMetadata() // This doesn't exist
export async function getTokenMetadata() // Use this for both
```

### 12. ConvertToAssetsMultiplier Initialization

**Match the original subgraph logic for initial values:**

```typescript
// OLD SUBGRAPH PATTERN:
vaultEntry.convertToAssetsMultiplier = new BigDecimal(ONE_BD);

// NEW ENVIO PATTERN:
let convertToAssetsMultiplier = ONE_BD as any;
// In a real implementation, you would calculate this based on vault state
// For now, use ONE_BD to match the original subgraph logic
```

**Import the correct constants:**
```typescript
import { ONE_BI, ZERO_BI, ZERO_BD, ONE_BD } from "./utils/constants";
```

### 13. Environment Variables for RPC Access

**Set up environment variables for contract state fetching:**

```bash
# .env file
RPC_URL=https://rpc.ankr.com/megaeth_testnet
```

**Install required dependencies:**
```bash
pnpm add viem dotenv
```

**Load environment variables in contract helpers:**
```typescript
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Create a public client for reading contract state
const publicClient = createPublicClient({
  chain: avalancheFuji,
  transport: http(process.env.RPC_URL),
});
```

### 14. Optimized Token Metadata Fetching

**Only fetch token metadata when token doesn't exist:**

```typescript
// Get or create Token entity - only fetch token metadata if token doesn't exist
let token = await context.Token.get(event.params.token);

if (!token) {
  // Only fetch token metadata when token doesn't exist (optimization)
  const tokenMetadata = await getTokenMetadata(event.params.token);
  
  token = {
    id: event.params.token,
    name: tokenMetadata.name,
    symbol: tokenMetadata.symbol,
    decimals: BigInt(tokenMetadata.decimals),
    // ... other fields
  };
  context.Token.set(token);
}
// If token exists, use existing data - no RPC call needed
```

### 15. Complete Contract Factory Implementation

**Full example with all optimizations:**

```typescript
ContractFactory.ContractCreated.handler(async ({ event, context }) => {
  try {
    // Get or create ContractFactory entity
    let contractFactory = await context.ContractFactory.get(ONE_BI.toString());
    if (!contractFactory) {
      contractFactory = {
        id: ONE_BI.toString(),
        totalContracts: ZERO_BI,
        timestamp: BigInt(event.block.timestamp),
        lastUpdate: BigInt(event.block.timestamp),
      };
    }

    // Update contract factory stats
    const updatedContractFactory = {
      ...contractFactory,
      totalContracts: contractFactory.totalContracts + ONE_BI,
      lastUpdate: BigInt(event.block.timestamp),
    };
    context.ContractFactory.set(updatedContractFactory);

    // Fetch ERC20 metadata for both contract and token (parallel)
    const [contractMetadata, tokenMetadata] = await Promise.all([
      getTokenMetadata(event.params.contract), // Contract is also an ERC20 token
      getTokenMetadata(event.params.token), // Token is an ERC20 token
    ]);
    
    // Create ContractDataEntity with contract's ERC20 metadata
    const contract: ContractDataEntity = {
      id: event.params.contract,
      name: contractMetadata.name, // Use contract's ERC20 metadata
      symbol: contractMetadata.symbol, // Use contract's ERC20 metadata
      decimals: BigInt(contractMetadata.decimals), // Use contract's ERC20 decimals
      manager: event.params.poolManager,
      timestamp: BigInt(event.block.timestamp),
      lastUpdate: BigInt(event.block.timestamp),
      fee: ZERO_BI,
      depositApy: ZERO_BI, // Will be calculated later
      convertToAssetsMultiplier: ONE_BD as any, // Match original subgraph logic
      totalDepositsVolume: ZERO_BI,
      totalWithdrawalsVolume: ZERO_BI,
      totalAssets: ZERO_BI, // Will be updated later
      totalShares: ZERO_BI, // Will be updated later
      token_id: event.params.token,
      contractFactory_id: ONE_BI.toString(),
    };

    // Get or create Token entity - only fetch if doesn't exist
    let token = await context.Token.get(event.params.token);
    
    if (!token) {
      // Only fetch token metadata when token doesn't exist (optimization)
      token = {
        id: event.params.token,
        name: tokenMetadata.name,
        symbol: tokenMetadata.symbol,
        decimals: BigInt(tokenMetadata.decimals),
        rate: ZERO_BD as any,
        dataFeedId: event.params.token,
        updatedAt: BigInt(event.block.timestamp),
        blockNumber: BigInt(event.block.number),
        blockTimestamp: BigInt(event.block.timestamp),
        transactionHash: event.transaction.hash,
        address: event.params.token,
      };
      context.Token.set(token);
    }

    // Set convertToAssetsMultiplier to ONE_BD (match original subgraph)
    const updatedContract: ContractDataEntity = {
      ...contract,
      convertToAssetsMultiplier: ONE_BD as any,
    };

    context.ContractDataEntity.set(updatedContract);

  } catch (error) {
    console.error(`Error in VaultCreated handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

### 16. Network Configuration

**Configure the correct network for your indexer:**

```typescript
// Create a public client for reading contract state
// Using MegaETH testnet (network ID 6342)
const publicClient = createPublicClient({
  chain: {
    id: 6342,
    name: 'MegaETH Testnet',
    network: 'megaeth-testnet',
    nativeCurrency: {
      decimals: 18,
      name: 'MegaETH',
      symbol: 'METH',
    },
    rpcUrls: {
      default: {
        http: [process.env.RPC_URL || 'https://rpc.ankr.com/megaeth_testnet'],
      },
      public: {
        http: [process.env.RPC_URL || 'https://rpc.ankr.com/megaeth_testnet'],
      },
    },
  },
  transport: http(process.env.RPC_URL),
});
```

**Set up environment variables:**
```bash
# .env file
RPC_URL=https://rpc.ankr.com/megaeth_testnet
```

**Load environment variables:**
```typescript
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();
```

**Common Network IDs:**
- MegaETH Testnet: 6342
- Ethereum Mainnet: 1
- Avalanche Fuji: 43113
- Polygon Mumbai: 80001

**Check your config.yaml for the correct network ID:**
```yaml
networks:
- id: 6342  # This determines which network to use
  start_block: 0
```

### 17. Factory Contract Migration Pattern

**Implement factory contract handlers with address filtering and entity creation:**

```typescript
// Reference: original-subgraph/src/factory.ts - handleContractCreated
Factory.ContractCreated.handler(async ({ event, context }) => {
  try {
    // Skip specific addresses (from original subgraph logic)
    const contractAddress = event.params.contract.toLowerCase();
    if (
      contractAddress === "0xSpecificAddress1" ||
      contractAddress === "0xSpecificAddress2"
    ) {
      context.log.info(`Skip datasource from wrong param ${contractAddress}`);
      return;
    }

    context.log.info(`handleContractCreated ${contractAddress}`);

    // Create event entity with correct ID (from original subgraph)
    const entity: ContractCreated = {
      id: event.params.contract, // Use contract address as ID like original subgraph
      param1: event.params.param1,
      param2: event.params.param2,
      contract: event.params.contract,
      blockNumber: BigInt(event.block.number),
      blockTimestamp: BigInt(event.block.timestamp),
      transactionHash: event.transaction.hash,
    };

    context.ContractCreated.set(entity);

    // Get or create related entities (example: tokens)
    let relatedEntity = await context.RelatedEntity.get(event.params.relatedParam);
    if (!relatedEntity) {
      try {
        const metadata = await getEntityMetadata(event.params.relatedParam);
        
        context.log.info(
          `CONTRACT CREATED :: FOR RELATED ENTITY ADDRESS:${event.params.relatedParam} NAME:${metadata.name} SYMBOL:${metadata.symbol}`
        );

        const newRelatedEntity: RelatedEntity = {
          id: event.params.relatedParam,
          name: metadata.name,
          symbol: metadata.symbol,
          // ... other fields
          blockNumber: BigInt(event.block.number),
          blockTimestamp: BigInt(event.block.timestamp),
          transactionHash: event.transaction.hash,
        };
        context.RelatedEntity.set(newRelatedEntity);
      } catch (error) {
        context.log.error(`Error fetching metadata for ${event.params.relatedParam}: ${error}`);
      }
    }

  } catch (error) {
    context.log.error(`Error in ContractCreated handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

**Key Features:**
1. **Address Filtering**: Skip specific addresses from original subgraph logic
2. **Contract Registration**: Register new contracts using `context.addContract()`
3. **Correct Entity ID**: Use event parameter as ID (matches original subgraph pattern)
4. **Immutable Object Handling**: Create new objects instead of modifying read-only ones
5. **Metadata Fetching**: Fetch contract state for related entities
6. **Conditional Entity Creation**: Only create entities if they don't exist (optimization)
7. **Proper Logging**: Use `context.log.info` and `context.log.error` instead of `console.log`
8. **Error Handling**: Proper error handling for RPC calls

**Important Patterns:**
- **Entity ID**: Use `event.params.contract` instead of `${event.chainId}_${event.transaction.hash}_${event.logIndex}`
- **Immutable Objects**: Create new objects (`newRelatedEntity`) instead of modifying read-only ones
- **Logging**: Use `context.log.info` and `context.log.error` for proper Envio logging

**Configuration Requirements:**
```yaml
# config.yaml
- event: ContractCreated(address indexed param1, address indexed param2, address contract)
  field_selection:
    transaction_fields:
      - hash
```

### 18. Logging Best Practices

**Use Envio's logging system instead of console.log:**

```typescript
// ‚ùå AVOID - Console logging
console.log(`Processing event: ${event.params.value}`);
console.error(`Error: ${error}`);

// ‚úÖ USE - Envio logging
context.log.info(`Processing event: ${event.params.value}`);
context.log.error(`Error: ${error}`);
context.log.warn(`Warning: ${warning}`);
context.log.debug(`Debug info: ${debugInfo}`);
```

**Available Logging Methods:**
- `context.log.info()` - General information
- `context.log.error()` - Error messages
- `context.log.warn()` - Warning messages
- `context.log.debug()` - Debug information

### 19. Immutable Object Handling

**When working with entities from context, create new objects:**

```typescript
// ‚ùå AVOID - Modifying read-only objects
let entity = await context.Entity.get(id);
if (entity) {
  entity.field = newValue; // This will fail - object is immutable
  context.Entity.set(entity);
}

// ‚úÖ USE - Create new objects with spread operator
let entity = await context.Entity.get(id);
if (entity) {
  const updatedEntity: Entity = {
    ...entity, // Spread existing properties
    field: newValue, // Add new/modified properties
    updatedAt: BigInt(event.block.timestamp),
  };
  context.Entity.set(updatedEntity);
}
```

**For New Entity Creation:**
```typescript
// ‚úÖ CORRECT - Create new entity object
const newEntity: Entity = {
  id: event.params.id,
  field1: event.params.field1,
  field2: event.params.field2,
  // ... other fields
};
context.Entity.set(newEntity);
```

### 20. Multiple Events with Same Name

**When a contract has multiple events with the same name but different signatures, use aliases:**

```yaml
# config.yaml
- name: Contract
  handler: src/contract.ts
  events:
    # First event with default name
    - event: EventName(address indexed param1, address indexed param2, uint256 value)
      field_selection:
        transaction_fields:
          - hash
    # Second event with same name but different signature - use alias
    - event: EventName(address indexed param3, address param4, uint256 value)
      name: EventNameAlias
      field_selection:
        transaction_fields:
          - hash
```

**Handler Implementation:**
```typescript
// First event handler
Contract.EventName.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    param1: event.params.param1,
    param2: event.params.param2,
    value: event.params.value,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };
  context.EventEntity.set(entity);
});

// Second event handler with alias
Contract.EventNameAlias.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    param3: event.params.param3,
    param4: event.params.param4,
    value: event.params.value,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };
  context.EventEntity.set(entity);
});
```

**Key Points:**
1. **Use `name` field** in config.yaml to create aliases for events with same name
2. **Different signatures** require different handlers
3. **Same entity type** can be used if the data structure is similar
4. **Field selection** must be specified for each event that needs transaction data
5. **Regenerate types** after adding new events with `pnpm codegen`

**Example: Pool Withdraw Events**
```yaml
# First Withdraw event (standard ERC4626)
- event: Withdraw(address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares)

# Second Withdraw event (pool-specific)
- event: Withdraw(address indexed poolAddress, address caller, address indexed receiver, uint256 assets, uint256 shares)
  name: WithdrawPool
  field_selection:
    transaction_fields:
      - hash
```

### 21. Quality Check and Fix Common Issues

**CRITICAL: At the end of each migration step, ALWAYS check for and fix these common issues:**

#### **Issue 1: Entity Type Import Confusion**
**PROBLEM:** Importing entity types from `"generated"` instead of `"generated/src/db/Entities.gen"`
**SYMPTOM:** TypeScript errors like "Pair refers to a value, but is being used as a type"
**SOLUTION:** Use correct import paths:
```typescript
// ‚ùå WRONG - Imports contract handlers, not entity types
import { Pair, Token } from "generated";

// ‚úÖ CORRECT - Imports entity types
import { Pair_t, Token_t } from "generated/src/db/Entities.gen";
```

#### **Issue 2: BigDecimal vs bigint Type Mismatches**
**PROBLEM:** Using wrong types for entity fields
**SYMPTOM:** TypeScript errors like "Type 'BigNumber' is not assignable to type 'bigint'"
**SOLUTION:** Match entity field types exactly:
```typescript
// ‚ùå WRONG - Token entity expects bigint for totalSupply
export function fetchTokenTotalSupply(tokenAddress: string): BigDecimal {
  return ZERO_BD;
}

// ‚úÖ CORRECT - Token entity expects bigint for totalSupply
export function fetchTokenTotalSupply(tokenAddress: string): bigint {
  return ZERO_BI;
}
```

#### **Issue 3: Entity Field Name Mismatches**
**PROBLEM:** Using wrong field names that don't match generated types
**SYMPTOM:** TypeScript errors like "Property 'token0' does not exist on type 'Pair_t'"
**SOLUTION:** Use exact field names from generated types:
```typescript
// ‚ùå WRONG - Field names don't match generated types
const pair: Pair_t = {
  token0: token0.id,  // Should be token0_id
  token1: token1.id,  // Should be token1_id
};

// ‚úÖ CORRECT - Field names match generated types
const pair: Pair_t = {
  token0_id: token0.id,
  token1_id: token1.id,
};
```

#### **Issue 4: Missing BigDecimal Import**
**PROBLEM:** Not importing BigDecimal from the correct location
**SYMPTOM:** TypeScript errors like "Cannot find name 'BigDecimal'"
**SOLUTION:** Import from generated types:
```typescript
// ‚ùå WRONG - Direct import from bignumber.js
import { BigDecimal } from 'bignumber.js';

// ‚úÖ CORRECT - Import from generated types (which re-exports BigNumber)
import { BigDecimal } from 'generated';
```

#### **Issue 5: Hardcoded Values Instead of Constants**
**PROBLEM:** Using hardcoded addresses/values instead of constants defined in the original subgraph
**SYMPTOM:** Inconsistent with original subgraph patterns, potential for errors if addresses change
**SOLUTION:** Always use constants from the original subgraph:
```typescript
// ‚ùå WRONG - Hardcoded address
const factory = await context.UniswapFactory.get('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f');

// ‚úÖ CORRECT - Use constant from original subgraph
const factory = await context.UniswapFactory.get(FACTORY_ADDRESS);
```

**CHECKLIST for Constants:**
1. **Look for hardcoded addresses** in your handlers
2. **Check what constants the original subgraph uses** (e.g., `FACTORY_ADDRESS`, `ADDRESS_ZERO`)
3. **Import and use those constants** instead of hardcoded values
4. **Maintain consistency** with the original subgraph's approach

**QUALITY CHECK CHECKLIST:**
After each step, run these commands to verify:
```bash
# 1. Check if codegen still works
pnpm codegen

# 2. Check if TypeScript compiles (skip lib check to avoid generated file issues)
npx tsc --noEmit --skipLibCheck src/path/to/your/files.ts

# 3. üö® CRITICAL: Test runtime execution
TUI_OFF=true pnpm dev

# 4. Fix any issues found before proceeding to next step
```

**üö® RUNTIME TESTING IS MANDATORY:**
- **TypeScript compilation only catches syntax errors**
- **Runtime errors (database issues, missing entities, logic errors) only appear when running the indexer**
- **Test after EVERY code change to catch issues immediately**
- **Never proceed to the next step until the indexer runs successfully**

**IMPORTANT:** Never proceed to the next step until all TypeScript compilation errors are resolved and codegen works successfully.

**NOTE: Some errors are expected during migration and should be ignored until later steps:**
- **Expected errors:** References to entities/handlers that haven't been implemented yet
- **Expected errors:** Missing imports for files that will be created in future steps
- **Expected errors:** Unused variables/functions that will be implemented later

**Only fix errors that prevent:**
1. **Codegen from working** - These must be fixed immediately
2. **TypeScript compilation** - These must be fixed immediately  
3. **Basic file structure** - These must be fixed immediately

**CRITICAL: Field Selection for Transaction Data**
When you need access to `event.transaction.hash` or other transaction fields, you MUST add field selection in config.yaml:

```yaml
- event: Transfer(address indexed from, address indexed to, uint256 value)
  field_selection:
    transaction_fields:
      - hash
```

**IMPORTANT: This applies to ALL events that need transaction data, not just Transfer events.**
**Common events that need transaction hash access:**
- **Transfer events** - for transaction tracking
- **Mint events** - for linking to transactions
- **Burn events** - for linking to transactions  
- **Swap events** - for transaction tracking
- **Any event that creates or updates Transaction entities**

**ALWAYS check if your handler needs `event.transaction.hash` and add `field_selection` BEFORE implementing the handler logic.**

**Without field selection:**
- `event.transaction.hash` will be undefined
- `event.transaction` will be empty `{}`
- You'll get TypeScript errors about missing properties

**With field selection:**
- `event.transaction.hash` will be available
- `event.transaction` will have the specified fields
- Code will compile correctly

**Examples of errors to ignore for now:**
```typescript
// ‚ùå IGNORE - Will be fixed when we implement the handler
// Error: Cannot find name 'handleMint'
Pair.Mint.handler(handleMint);

// ‚ùå IGNORE - Will be fixed when we create the entity
// Error: Cannot find name 'MintEvent'
const mintEvent: MintEvent = { ... };

// ‚ùå IGNORE - Will be fixed when we implement the function
// Error: Cannot find name 'calculateFees'
const fees = calculateFees(amount);
```

**COMMON FIXES TO APPLY AUTOMATICALLY:**
1. **Fix entity type imports** - Use `"generated/src/db/Entities.gen"` for entity types
2. **Fix type mismatches** - Match entity field types exactly (BigDecimal vs bigint)
3. **Fix field names** - Use exact field names from generated types
4. **Fix BigDecimal imports** - Import from `"generated"` not `"bignumber.js"`
5. **Fix entity type annotations** - Use `Pair_t` not `Pair` for entity types
6. **Fix transaction field access** - Add `field_selection` in config.yaml for `event.transaction.hash`
7. **Fix hardcoded values** - Use constants from original subgraph instead of hardcoded addresses/values
8. **Fix missing field selection** - Add `field_selection` for ALL events that need transaction data (not just Transfer)
9. **Fix missing @derivedFrom** - Ensure ALL entity arrays have `@derivedFrom(field: "fieldName")` directives
10. **Fix @derivedFrom array access** - Don't try to access `@derivedFrom` arrays in handlers (they're virtual fields)
11. **Check helper function dependencies** - Ensure all called functions without entity dependencies are implemented
12. **üö® CRITICAL: Check entity type mismatches and database schema compatibility** - ALWAYS verify that the types you're setting in code match the schema entity property types exactly, and ensure database schema compatibility

**EXAMPLE OF COMPLETE FIX:**
```typescript
// ‚ùå BEFORE - Multiple issues
import { Pair, Token } from "generated";
import { BigDecimal } from 'bignumber.js';

const pair: Pair = {  // Wrong type
  token0: token0.id,  // Wrong field name
  totalSupply: ZERO_BD,  // Wrong type (should be bigint)
};

// ‚úÖ AFTER - All issues fixed
import { Pair_t, Token_t } from "generated/src/db/Entities.gen";
import { BigDecimal } from 'generated';

const pair: Pair_t = {  // Correct type
  token0_id: token0.id,  // Correct field name
  totalSupply: ZERO_BI,  // Correct type (bigint)
};
```

**EXAMPLE OF FIELD SELECTION FIX:**
```yaml
# ‚ùå BEFORE - No field selection, transaction.hash will be undefined
- event: Transfer(address indexed from, address indexed to, uint256 value)

# ‚úÖ AFTER - With field selection, transaction.hash will be available
- event: Transfer(address indexed from, address indexed to, uint256 value)
  field_selection:
    transaction_fields:
      - hash
```

**EXAMPLE OF @derivedFrom FIX:**
```graphql
# ‚ùå BEFORE - Missing @derivedFrom, will cause "EE211: Arrays of entities is unsupported"
type Transaction {
  mints: [Mint!]!
  burns: [Burn!]!
  swaps: [Swap!]!
}

# ‚úÖ AFTER - With @derivedFrom, schema will compile successfully
type Transaction {
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
}
```

**EXAMPLE OF CONSTANTS FIX:**
```typescript
// ‚ùå BEFORE - Hardcoded address, inconsistent with original subgraph
const factory = await context.UniswapFactory.get('0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f');

// ‚úÖ AFTER - Use constant from original subgraph, consistent and maintainable
const factory = await context.UniswapFactory.get(FACTORY_ADDRESS);
```

**A complete migration should pass ALL these checks before being considered production-ready.**
```

## **22. Async/Await Validation**

**Check that all necessary calls and functions have `async` and `await`:**

```typescript
// ‚ùå WRONG - Missing async/await
export function updateTokenDayData() {
  const bundle = context.Bundle.get(`${chainId}-1`); // Returns {} without await
}

// ‚úÖ CORRECT - Proper async/await
export async function updateTokenDayData() {
  const bundle = await context.Bundle.get(`${chainId}-1`); // Returns actual data
}
```

**Note: `context.Entity.set()` does NOT need `await` - it's synchronous.**

**This step is critical for preventing database operation failures and ensuring data integrity.**

## **23. Handling Subgraph Array Access Patterns**

**IMPORTANT: When the subgraph accesses arrays from relational entities, Envio requires a different approach.**

### **The Problem:**
**Subgraph pattern:**
```typescript
// Subgraph can directly access entity arrays
transaction.mints.push(mint);
transaction.burns.push(burn);
transaction.swaps.push(swap);
```

**Envio limitation:**
- `@derivedFrom` arrays are **virtual fields** - they don't exist in generated types
- You **cannot directly access** `transaction.mints`, `transaction.burns`, etc.
- These arrays are populated automatically by Envio when querying the API

### **The Solution:**
**Use `context.Entity.getWhere.fieldName.eq(value)` to query for related entities:**

```typescript
// ‚ùå WRONG - Trying to access virtual arrays directly
const mints = transaction.mints; // This will NOT work
const burns = transaction.burns; // This will NOT work

// ‚úÖ CORRECT - Query for related entities using indexed fields
const mint = await context.Mint.getWhere.transaction_id.eq(transactionId);
const burn = await context.Burn.getWhere.transaction_id.eq(transactionId);
const swap = await context.Swap.getWhere.transaction_id.eq(transactionId);
```

### **Example Implementation:**
```typescript
// When you need to find existing entities by transaction
const existingMint = await context.Mint.getWhere.transaction_id.eq(transactionId);
const existingBurn = await context.Burn.getWhere.transaction_id.eq(transactionId);

if (existingMint) {
  // Update existing mint entity
  const updatedMint: Mint = {
    ...existingMint,
    amount0: event.params.amount0,
    amount1: event.params.amount1,
    // ... other updates
  };
  context.Mint.set(updatedMint);
} else {
  // Create new mint entity
  const newMint: Mint = {
    id: mintId,
    transaction_id: transactionId,
    // ... other fields
  };
  context.Mint.set(newMint);
}
```

### **Key Points:**
- **Use `context.Entity.getWhere.fieldName.eq(value)`** for querying related entities
- **This simulates the subgraph's array access** by finding entities that reference the current entity
- **Always check if entities exist** before updating or creating
- **Use the spread operator** when updating existing entities (they're read-only)

## **24. Final Migration Verification: Handler and Helper Function Logic Review**

**üö® CRITICAL: This is the final step to ensure complete migration accuracy**

### **Step 1: Systematic Handler Logic Review**
**Go through each handler in each file one by one:**

1. **For each handler, compare the logic to the subgraph implementation**
2. **Identify any missing logic or unnecessary logic**
3. **Update the handler accordingly**
4. **Run the same check again on the updated code** (you'll likely find something else/new)
5. **Repeat this process until the logic is correct**
6. **Do this slowly, one by one, for every handler**

**Why this iterative approach is critical:**
- **First pass** often misses subtle logic differences
- **Second pass** reveals issues introduced by the first pass
- **Multiple iterations** ensure complete accuracy
- **Slow, methodical review** prevents missing critical details

### **Step 2: Systematic Helper Function Logic Review**
**Go through each helper function in every file one by one:**

1. **For each helper function, compare the logic to the subgraph implementation**
2. **Identify any missing logic or unnecessary logic**
3. **Update the helper function accordingly**
4. **Run the same check again on the updated code**
5. **Repeat this process until the logic is correct**
6. **Do this slowly, one by one, for every helper function**

### **Step 3: MDC File Consultation**
**When uncertain about something, ALWAYS consult the MDC file:**

- **Check existing solutions** for similar problems
- **Reference the quality check checklist** to avoid common mistakes
- **Look for similar examples** in the MDC file
- **Use documented Envio patterns** instead of guessing

### **Step 4: Implementation Order**
**Follow this order for maximum efficiency:**

1. **Start with simple handlers** - those with minimal business logic
2. **Move to complex handlers** - those with extensive calculations or multiple entity updates
3. **Review helper functions** - after handlers are complete
4. **Final integration check** - ensure all pieces work together

### **Step 5: Verification Checklist**
**After each handler/function review, verify:**

- [ ] **Logic matches subgraph exactly** - no missing or extra logic
- [ ] **All edge cases handled** - same conditional branches as subgraph
- [ ] **Entity operations correct** - proper loading, updating, saving
- [ ] **Helper function calls complete** - all required functions called
- [ ] **Error handling matches** - same try/catch and validation logic
- [ ] **Calculations identical** - same mathematical operations and precision

### **Example of Complete Logic Review:**
```typescript
// ‚ùå BEFORE - Missing logic from subgraph
export async function handleMint(event: any, context: any) {
  const mint: Mint = {
    id: mintId,
    amount0: event.params.amount0,
    amount1: event.params.amount1,
    // Missing: sender, to, feeTo, feeLiquidity, amountUSD calculations
  };
  context.Mint.set(mint);
}

// ‚úÖ AFTER - Complete logic matching subgraph
export async function handleMint(event: any, context: any) {
  // Load existing mint entity (created by Transfer handler)
  const existingMint = await context.Mint.getWhere.transaction_id.eq(transactionId);
  
  if (existingMint) {
    // Update existing mint with complete data
    const updatedMint: Mint = {
      ...existingMint,
      sender: event.params.sender,
      to: event.params.to,
      amount0: event.params.amount0,
      amount1: event.params.amount1,
      feeTo: feeToAddress,
      feeLiquidity: calculatedFeeLiquidity,
      amountUSD: calculatedAmountUSD,
      logIndex: event.logIndex,
    };
    context.Mint.set(updatedMint);
  }
  
  // Update all related entities (token0, token1, pair, factory)
  // ... complete implementation matching subgraph
}
```

### **Why This Step is Critical:**
- **Ensures complete migration** - no functionality is lost
- **Maintains data accuracy** - same business logic as original
- **Prevents runtime errors** - all edge cases are handled
- **Guarantees compatibility** - same behavior as original subgraph

**This systematic review is the final quality gate before your migration is production-ready.**

## **25. Final Migration Verification: TODO Cleanup and Logic Verification**

**CRITICAL: This is the final step to ensure migration completeness**

### **Step 1: Comprehensive TODO Scan**
**Scan every file in your migrated codebase for TODO comments:**

```bash
# Search for all TODO comments across the codebase
grep -r "TODO" src/ --include="*.ts" --include="*.tsx"
grep -r "FIXME" src/ --include="*.ts" --include="*.tsx"
grep -r "HACK" src/ --include="*.ts" --include="*.tsx"
```

### **Step 2: TODO Classification and Action**
**For each TODO found, determine the appropriate action:**

#### **Category A: Already Implemented**
- **Symptom:** TODO references functionality that exists elsewhere
- **Action:** Remove the TODO comment
- **Example:** `// TODO: Implement fetchTokenSymbol` when the function exists

#### **Category B: Not Yet Implemented**
- **Symptom:** TODO references functionality that's missing
- **Action:** Implement the missing functionality
- **Priority:** High - must be completed before migration is done

#### **Category C: Future Enhancement**
- **Symptom:** TODO references optional features not in original subgraph
- **Action:** Document as future work, don't block migration
- **Example:** `// TODO: Add monitoring and alerting`

### **Step 3: Logic Comparison with Original Subgraph**
**For each function, compare with the original subgraph implementation:**

#### **Check These Areas:**
1. **Function signature** - Parameters, return types, async/await
2. **Core business logic** - All conditional branches, calculations
3. **Error handling** - Try/catch blocks, null checks, validation
4. **Entity operations** - Loading, updating, saving entities
5. **Helper function calls** - All required helper functions called
6. **Edge cases** - Special conditions, boundary checks

#### **Common Missing Logic:**
- **Null checks** - Missing validation for loaded entities
- **Error handling** - Missing try/catch blocks
- **Edge case handling** - Missing special condition logic
- **Helper function calls** - Missing calls to required functions
- **Entity updates** - Missing field updates or saves

### **Step 4: Implementation Order**
**Implement missing functionality in dependency order:**

1. **Base functions first** - Functions with no dependencies
2. **Helper functions** - Functions used by handlers
3. **Handler logic** - Complete event handling logic
4. **Integration points** - Cross-entity updates and relationships

### **Step 5: Verification Checklist**
**After cleanup, verify:**

- [ ] **No TODO comments remain** in production code
- [ ] **All functions have complete logic** matching original subgraph
- [ ] **All edge cases handled** as in original implementation
- [ ] **All helper functions called** where required
- **All entities properly updated** and saved
- [ ] **Error handling complete** for all failure scenarios

### **Example of Complete TODO Cleanup:**
```typescript
// ‚ùå BEFORE - Incomplete implementation with TODO
export function findEthPerToken(token: any, context: any): BigDecimal {
  // TODO: Implement complete logic from original subgraph
  return ZERO_BD;
}

// ‚úÖ AFTER - Complete implementation matching original
export function findEthPerToken(token: any, context: any): BigDecimal {
  if (token.id === REFERENCE_TOKEN) {
    return ONE_BD;
  }

  const bundle = context.Bundle.get('1');
  if (!bundle) {
    return ZERO_BD;
  }

  // ... complete implementation matching original subgraph
}
```

**This final step ensures your migration is production-ready with no missing functionality.**

## Entity Relationships

**IMPORTANT**: Entity relationships work differently in Envio vs TheGraph subgraphs.

### Correct Pattern for Entity Relationships in Envio:

1. **Schema Definition**: Define entity relationships using the direct entity type name in the entity that references another entity
   ```graphql
   type EntityA {
     id: ID!
     relatedEntity: EntityB!        # Direct entity type, not relatedEntity_id: String!
     anotherEntity: EntityC!        # Direct entity type, not anotherEntity_id: String!
   }
   ```

2. **@derivedFrom in Related Entity**: Add `@derivedFrom` in the entity being referenced to establish the reverse relationship
   ```graphql
   type EntityB {
     id: ID!
     # ... other fields
     
     # Reverse relationships - these are VIRTUAL fields
     entityARelationship: [EntityA!]! @derivedFrom(field: "relatedEntity")
   }
   ```

3. **Code Implementation**: When setting entity relationships, use the `_id` suffix and provide the entity identifier
   ```typescript
   // CORRECT: Set entity relationships using _id suffix
   const entityA: EntityA = {
     id: entityId,
     relatedEntity_id: entityB.id,    // Use _id suffix, reference source entity's _id field
     anotherEntity_id: entityC.id,    // Use _id suffix, reference source entity's _id field
   };
   ```

4. **Relationship Access Pattern**:
   - **Schema**: `fieldName: EntityType!` (e.g., `relatedEntity: EntityB!`)
   - **Code Setting**: `fieldName_id: entityIdentifier`
   - **Entity Identifier can be**:
     - Direct address/ID: `relatedEntity_id: "0x1234..."`
     - From another entity: `relatedEntity_id: sourceEntity.relatedEntity_id`
     - From event data: `relatedEntity_id: event.params.entityId`

5. **Key Points**:
   - Use `@derivedFrom` in the entity being referenced (not in the entity doing the referencing)
   - Always use the `_id` suffix when setting entity relationships in code
   - The `_id` field contains the entity's unique identifier (usually the address for contracts)
   - Entity relationships are established by setting the `_id` field, not the full entity object

### Relationship Flow Examples:

**Example 1: Setting Entity Relationship Using Just the Address**
- **EntityA** has array property `[EntityB!]!` that references **EntityB**
- **EntityB** exists independently
- We can set the relationship directly with the address (giving the pointer to the collection it belongs to):
  ```typescript
  // Direct address approach - you're giving the pointer to the collection it belongs to
  entityB_id: "0x6b175474e89094c44da98b954eedeac495271d0f"
  ```

**Example 2: Setting Entity Relationship from Another Entity Which Points to the Same Collection**
- **EntityA** has array property `[EntityB!]!` that references **EntityB**
- **EntityC** also references **EntityB** (via some field)
- **EntityA** has array property `[EntityC!]!` that references **EntityC**
- If you know EntityC points to the same EntityB collection, you can reference it through EntityC:
  ```typescript
  // From EntityC that points to the same EntityB collection
  entityB_id: entityC.entityBField_id
  ```

**Examples**:
```typescript
// Setting relationship directly with address
entityB_id: "0x6b175474e89094c44da98b954eedeac495271d0f"

// Setting relationship from another entity that references it
entityB_id: sourceEntity.entityBField_id

// Setting relationship from event data
entityB_id: event.params.entityId

// Setting relationship from a loaded entity
entityB_id: entity.id
```

### What NOT to do:
- ‚ùå Don't use `@derivedFrom` in the entity doing the referencing
- ‚ùå Don't define schema fields as `entityB_id: String!` 
- ‚ùå Don't try to set the full entity object in relationships
- ‚ùå Don't use `entityB: sourceEntity.entityBField_id` (missing _id suffix)

### What TO do:
- ‚úÖ Define schema as `entityB: [EntityB!]!` in the referencing entity
- ‚úÖ Add `@derivedFrom(field: "entityB")` in the EntityB entity
- ‚úÖ Set in code as `entityB_id: entityIdentifier`
- ‚úÖ Always use the `_id` suffix when setting relationships
- ‚úÖ Provide the entity identifier (address, ID, or reference from another entity)
```

**üö® CRITICAL: Entity Type Mismatch and Database Schema Compatibility**

**Rule 12: Check entity type mismatches and database schema compatibility - ALWAYS verify that the types you're setting in code match the schema entity property types exactly**

**Key Points:**
- **Check the GraphQL schema** (`schema.graphql`) for each entity's field types
- **Compare with your code** - ensure types match exactly
- **Test with TypeScript** - `pnpm tsc --noEmit` will catch many type mismatches
- **Test runtime execution** - `TUI_OFF=true pnpm dev` will catch database compatibility issues

**Common Schema Types and Their Code Equivalents:**
- `Int!` ‚Üí `number` (e.g., `dayStartTimestamp`)
- `BigInt!` ‚Üí `BigInt` or constants like `ZERO_BI`, `ONE_BI`
- `BigDecimal!` ‚Üí `BigDecimal` or constants like `ZERO_BD`, `ONE_BD`
- `Bytes!` ‚Üí `string` (hex addresses)
- `String!` ‚Üí `string`
- `Boolean!` ‚Üí `boolean`
- `EntityType!` ‚Üí `entityType_id: string` (for relationships - see Entity Relationships section)

**Example of Type Mismatch:**
```typescript
// ‚ùå WRONG - Schema expects Int!, but code sets BigInt
// Schema: date: Int!
// Code: date: BigInt(dayStartTimestamp)

// ‚úÖ CORRECT - Schema expects Int!, code sets number
// Schema: date: Int!
// Code: date: dayStartTimestamp  // dayStartTimestamp is already a number
```
```

